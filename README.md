# Local_search

Introduction to AI Assignment 1
Individual Work
1. Identify two very different existing AI systems and characterize them based on
the PEAS problem formulation. Give a detailed explanation of the applications
based on these four fundamental concepts. (Read Part I, Chapter 1, and
Chapter 2)

Deliverables: Detailed explanation of the problems using PEAS (10 points)

2. Using your self-made graph library, try loading the graph data presented on page
83rd of the textbook.
Deliverables: A text file containing the graph connection and Code to read it.
Your code should read this text file and build the graph. Hence, for your graph
create code, you should only provide the file name as a parameter (2 points)

3. Implement BFS, DFS, Dijkstra's shortest path, and A* Search algorithm. Using
the graph from Question 2, evaluate each of your algorithms and benchmark
them. The benchmark should be finding the path between each node. The
benchmark result should include the average time needed to find a solution and
the average solution length of each algorithm.
a. Bonus - create random nodes of your own and randomly develop
connections with the original graph. The number of your random nodes
should be 1x, 2x, 3x, 4x.. of the original size. Evaluate each algorithm on
these graph sizes and observe what happens to the benchmark. Use
matplotlib.pyplot to plot their average time and solution length on each
graph sizes
Deliverables: Code for each Algorithm, and a detailed report on the benchmark
result. (20 points + 10 points for bonus)
Group work (only 2 students, don’t ask if you can be more or less)

4. In graph theory and network analysis, indicators of centrality assign numbers or
rankings to nodes within a graph corresponding to their network position. For
example, In a given social network, questions like who is an influencer? Who is
the significant person? Who is the linkage between societies/groups? can easily
be answered by calculating node centrality rankings.
There are several centralities types. Use your A* search & Dijkstra’s algorithms
with your graph library to calculate Degree, Closeness, and Betweenness
centralities on the graph from Question 2. (You have to read online how to
calculate these centralities). Compare your A* and Dijkstra’s Algorithm results.
By looking at the graph drawing in the textbook, explain the results.
Deliverables: Code for each Algorithm, and a detailed report on the benchmark
result. (20 points)

[report.pdf](https://github.com/HenokMekuanint/Local_search/files/9035082/report.pdf)

